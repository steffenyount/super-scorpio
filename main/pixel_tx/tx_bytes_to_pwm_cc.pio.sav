;  Copyright (C) 2024 Steffen Yount
;
;  Licensed under the Apache License, Version 2.0 (the "License");
;  you may not use this file except in compliance with the License.
;  You may obtain a copy of the License at
;
;  http://www.apache.org/licenses/LICENSE-2.0
;
;  Unless required by applicable law or agreed to in writing, software
;  distributed under the License is distributed on an "AS IS" BASIS,
;  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;  See the License for the specific language governing permissions and
;  limitations under the License.

.program tx_bytes_to_pwm_cc

.wrap_target
    irq wait 0 rel      ; "data ready" sync point: irq -> ON (rxf entries ready), irq -> OFF (txf entries ready)

pull_no_wait:
    pull noblock        ; load the next "pwm_slice_tx_bytes" entry from txf or from the queue (X) if txf is empty
    mov osr, ::osr      ; bit-reverse the value to make its top bits accessible for "IN" instructions

    ; assemble left 16-bit B-channel PWM CC value for tx_byte - 0 (0b000): off, 3 (0b011): low, 7 (0b111): high
    in null, 13         ; pad
    in osr, 1           ; bit from "tx_byte.curr_byte"

    ; digress to advance the queue (Y to X) and then to save the shifted "pwm_slice_tx_bytes" entry into Y
    out null, 1         ; advance the "pwm_slice_tx_bytes" entry for the next bit of the byte sequence (shift OSR >> 1)
    mov x, y            ; advance the queue (Y to X)
    mov y, ::osr        ; enqueue the shifted "pwm_slice_tx_bytes" value into Y (bit-reversed back)

    ; resume the regular PWM CC value assembly steps
    out null, 7         ; advance to "tx_byte.tx_enabled"
    in osr, 1           ; bit from "tx_byte.tx_enabled"
    in osr, 1           ; bit from "tx_byte.tx_enabled"

    out null, 8         ; advance to next "tx_byte"

    ; assemble right 16-bit A-channel PWM CC value for tx_byte - 0 (0b000): off, 3 (0b011): low, 7 (0b111): high
    in null, 13         ; pad
    in osr, 1           ; bit from "tx_byte.curr_byte"
    out null, 8         ; advance to "tx_byte.tx_enabled"
    in osr, 1           ; bit from "tx_byte.tx_enabled"
    in osr, 1           ; bit from "tx_byte.tx_enabled" + auto-push

    ; if less than 2 entries in RX FIFO
    mov osr, x          ; stash temporarily
    mov x, status       ; status: all-ones if RX FIFO level < 2
    jmp !x restore_x_and_await_irq

    ; then keep pulling and processing
    mov x, osr          ; restore stashed value
    jmp pull_no_wait    ; goto directly to pull

    ; else signal rxf entries ready amd wait for next txf entries ready
restore_x_and_await_irq:
    mov x, osr          ; restore stashed value + wrap to irq + pull
.wrap

% c-sdk {
#include "tick_log/tick_log.h"

#define PIO_SM3_INTERRUPT_NUM (3u)
#define PIO_SM3_INTERRUPT_MASK (1u << PIO_SM3_INTERRUPT_NUM)
#define PIO_SM3_INTERRUPT_SOURCE_NUM (pis_interrupt3)
#define PIO_SM3_INTERRUPT_SOURCE_MASK (1u << PIO_SM3_INTERRUPT_SOURCE_NUM)
#define PIO_ALL_SM_INTERRUPTS_MASK (0x0fu)

static inline void tx_bytes_to_pwm_cc_program_init(PIO pio, uint sm, uint offset) {
    pio_sm_config sm_cfg = tx_bytes_to_pwm_cc_program_get_default_config(offset);

    // OUT shifts to right, no autopull
    sm_config_set_out_shift(&sm_cfg, true, false, 32);
    // IN shifts to left, with autopush
    sm_config_set_in_shift(&sm_cfg, false, true, 32);
    // MOV status indicate if there's less than 2 entries in the rxf
    sm_config_set_mov_status(&sm_cfg, STATUS_RX_LESSTHAN, 2u);

    pio_sm_init(pio, sm, offset, &sm_cfg);
    pio_sm_set_enabled(pio, sm, true);
}

static inline void init_pio_sms_for_tx_bytes_to_pwm_cc_program() {
    uint offset = pio_add_program(pio1, &tx_bytes_to_pwm_cc_program);
    for (uint sm = 0; sm < NUM_PIO_STATE_MACHINES; sm++) {
        tx_bytes_to_pwm_cc_program_init(pio1, sm, offset);
    }
}

static inline uint32_t pio1_sm3_get_rx_fifo_level() {
    return ((pio1->flevel & PIO_FLEVEL_RX3_BITS) >> PIO_FLEVEL_RX3_LSB);
}

static inline void wait_for_pio_sm3_ready() {
    uint32_t pio_sm3_ready_count = 0u;
    // ready when rxf is empty and interrupt is set
    while((pio1_sm3_get_rx_fifo_level() != 0) || !(pio1->irq & PIO_SM3_INTERRUPT_MASK)) {
        if (pio_sm3_ready_count++ > 1024) break;
//        tight_loop_contents();
    }
    if (pio_sm3_ready_count > 0u) {
        if (pio_sm3_ready_count > 1024) {
            log_tick("pio_sm3_ready_count > 1024");
        } else {

            log_tick("pio sm3 ready - after waiting");
        }

    } else {
        log_tick("pio sm3 ready");
    }
}

static inline void queue_up_next_pwm_cc_bit_values_in_rxf() {
//    log_tick("queue_up_next_pwm_cc_bit_values_in_rxf()");
    pio1->irq = PIO_ALL_SM_INTERRUPTS_MASK;
}
%}